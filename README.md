# System_Shell

**System_Shell** — это консольная программа, которая имитирует поведение командной строки. Причём **System_Shell** кроссплатформенна и работает как на Windows, так и на Linux.

## Краткий принцип работы программы:

1. При запуске `main.py`, функция `run()` запускает бесконечный цикл `while True`, который прерывается только при вводе пользователем команды `exit()`.
2. Программа считывает введённые пользователем команды и парсит их. Далее в зависимости от введённой команды программа вызывает соответствующую функцию (`ls`, `cd`, `cp`, `rm`, `mv` и т.д.).
3. Вызванная функция сама создаёт нужные для выполнения команды пути и зависимости. В большинстве функций основные действия (копирование, удаление, перемещение и т.д.) выполняются при помощи данных библиотек и их методов:

   - **os**: `os.listdir()`, `os.stat()`, `os.path.join()`, `os.chdir()`, `os.remove()`, `os.path.abspath()`, `os.makedirs()`
   - **shutil**: `shutil.copytree()`, `shutil.copy2()`, `shutil.rmtree()`, `shutil.move()`

4. После завершения выполнения команды (или если было вызвано исключение) результат выполнения команды добавляется в список обработанных команд (`self.history = []`) при помощи функции `add_to_history()`, а также записывается в файл `.history` при помощи функции `save_history()`.
5. После выполнения вышеизложенного алгоритма программа снова ожидает ввода команд от пользователя.

*6. Также у программы есть файл с тестами — `tests.py`, в котором реализованы базовые тесты каждой из функций, а также обработка исключений (`FileNotFoundError`, `PermissionError`, `IsADirectoryError`).

---

На этом основная часть описания программы для рядового пользователя окончена. Далее будет представлено подробное описание работы каждой из функций.

---

## Функция `check_history()`

Данная функция нужна для того, чтобы каждый новый запуск программы имел доступ к истории команд, обработанных предыдущими запусками.

**Принцип работы:**

1. Функция считывает данные об обработанных командах из файла `.history` и добавляет их в список `history`, чтобы данный запуск программы мог оперировать данными из прошлых запусков.

**Исключения:**

- `OSError`:
  - Вывод: `File with history didn't find.`

---

## Функция `save_history()`

Данная функция выполняет обратное к предыдущей действие — перезаписывает в файл `.history` последние 10 команд. Число 10 выбрано только лишь потому, что это учебный проект, и на данном этапе 10 последних команд в файле `.history` вполне достаточно для корректной работы с программой.

**Принцип работы:**

1. Функция берёт последние 10 команд из списка и перезаписывает файл `.history`, добавляя только последние 10 команд. При таком подходе файл `.history` всегда остаётся фиксированного объёма (в нём всегда `<= 10` команд), однако есть и минусы — в файле `.history` всегда хранится только последние 10 команд, а более ранние безвозвратно удаляются. Это можно балансировать при помощи изменения количества записываемых команд (например, с 10 до 50).

**Исключения:**

- `OSError`:
  - Вывод: `Could't save command history.`

---

## Функция `add_to_history()`

Данная функция добавляет команду и информацию о ней (её аргументы и атрибуты) в список команд. А также вызывает функцию `save_history`, которая, в свою очередь, добавляет эту команду в файл `.history`. Таким образом, данная функция является ключевой и выполняет весь путь по записи команды в историю после её выполнения программой.

**Принцип работы:**

1. Функция создаёт словарь, в который добавляет полученные ей данные о команде:
   - `'time'`: время выполнения команды,
   - `'command'`: имя команды,
   - `'args'`: аргументы (пути, флаги и т.д.),
   - `'status'`: статус выполнения (`success`/`error`),
   - `'current_dir'`: текущую директорию,
   - `'other_data'`: дополнительную информацию.
2. Далее функция добавляет созданный словарь в список команд.
3. После этого функция вызывает `save_history`, которая, в свою очередь, записывает эту команду в файл `.history`.

---

## Функция `ls()`

Данная функция соответствует команде `ls()` в консоли. Функция выводит пользователю список содержимого в указанной директории (по умолчанию в текущей директории). Также функция поддерживает флаг `-l`, который указывает функции, что нужно вывести подробную информацию об объектах в указанной директории.

**Принцип работы:**

1. Считывает директорию, о которой следует вывести информацию (по умолчанию текущая директория).
2. Далее с помощью `os.listdir()` получает список элементов в директории.
3. Если нет флага `-l`:
   - Объединяет элементы списка в строку, добавляя разделителями `\n`. И выводит эту строку пользователю.
   - Если есть флаг `-l`:
     1. Проходит по каждому элементу списка и с помощью `os.path.join()` составляет путь до него.
     2. Далее при помощи `os.stat()` получает информацию об элементе.
     3. Выводит пользователю строку с подробной информацией об элементе (размер, время последнего изменения, права доступа в цифровом виде).
4. Далее вызывает функцию `add_log()`, которая добавляет информацию о выполненной команде в лог-файл.
5. Вызывает функцию `add_to_history()`, которая записывает команду в историю.

**Исключения:**

- `OSError`:
  - Вывод: При появлении исключения выводит пользователю текст исключения.
  - Также как в пунктах 4-5 добавляет информацию об исключении в лог-файл и историю.

---

## Функция `cd()`

Данная функция соответствует команде `cd()` в консоли. Функция выполняет смену текущей директории.

**Принцип работы:**

1. Считывает директорию, в которую нужно перейти:
   - Если введено `".."`:
     - При помощи функции `os.path.dirname()` создаёт путь к предыдущей директории (от пути текущей директории отбрасывает её имя).
   - Если введено `"~"`:
     - Создаёт путь к корневой директории при помощи функции `os.path.expanduser()`. Данная функция преобразует символ `"~"` в путь к домашней директории.
   - Если введено название директории:
     - Создаёт полный (абсолютный) путь к данной директории при помощи функции `os.path.abspath()`.
2. Далее при помощи функции `os.chdir()` программа выполняет переход к новой директории.
3. Также при переходе изменяется константа, хранящая имя текущей директории.
4. Далее вызывает функцию `add_log()`, которая добавляет информацию о выполненной команде в лог-файл.
5. Вызывает функцию `add_to_history()`, которая записывает команду в историю.

**Исключения:**

- `FileNotFoundError`:
  - Вывод: `Directory '...' doesn't exist.`
- `OSError`:
  - Вывод: При появлении исключения выводит пользователю текст исключения.
  - Также как в пунктах 4-5 добавляет информацию об исключении в лог-файл и историю.

---

## Функция `cat()`

Данная функция соответствует команде `cat()` в консоли. Функция выводит содержимое указанного файла.

**Принцип работы:**

1. При помощи `os.path.join()` создаёт путь к указанному файлу.
2. Далее функция читает указанный файл и выводит его содержимое пользователю.
3. Далее вызывает функцию `add_log()`, которая добавляет информацию о выполненной команде в лог-файл.
4. Вызывает функцию `add_to_history()`, которая записывает команду в историю.

**Исключения:**

- `IsADirectoryError`:
  - Вывод: `"..." is a directory.`
- `OSError`:
  - Вывод: При появлении исключения выводит пользователю текст исключения.
  - Также как в пунктах 3-4 добавляет информацию об исключении в лог-файл и историю.

---

## Функция `cp()`

Данная функция соответствует команде `cp()` в консоли. Функция копирует указанные файлы и директории. Также функция поддерживает флаг `-r`, который применим только при копировании директорий и указывает функции, что следует рекурсивно скопировать указанную директорию.

**Принцип работы:**

1. При помощи `os.path.join()` создаёт пути к указанным файлам.
2. Проверяет, является ли объект «куда копировать» директорией:
   - Если является, то создаёт в этой директории файл с именем копируемого при помощи `basename()`. Точнее, он создаёт путь к этому файлу.
3. Проверяет, является ли копируемый объект директорией и наличие флага `-r`:
   1. Если объект — директория и есть флаг `-r`, то происходит рекурсивное копирование при помощи `shutil.copytree()`.
   2. Если объект — не директория, то происходит копирование его как файла при помощи `shutil.copy2()`.
   3. Если объект — директория, но нет флага `-r`, то вызывается исключение `IsADirectoryError`.
4. Далее вызывает функцию `add_log()`, которая добавляет информацию о выполненной команде в лог-файл.
5. Вызывает функцию `add_to_history()`, которая записывает команду в историю.

**Исключения:**

- `IsADirectoryError`:
  - Вывод: `"..." is a directory.`
- `OSError`:
  - Вывод: При появлении исключения выводит пользователю текст исключения.
  - Также как в пунктах 4-5 добавляет информацию об исключении в лог-файл и историю.

---

## Функция `mv()`

Данная функция соответствует команде `mv()` в консоли. Функция перемещает или переименовывает файлы.

**Принцип работы:**

1. При помощи `os.path.join()` создаёт пути к указанным файлам.
2. Проверяет, является ли объект «куда перемещать» директорией:
   - Если является, то создаёт в этой директории файл с именем перемещаемого при помощи `basename()`. Точнее, он создаёт путь к этому файлу.
3. Далее при помощи `shutil.move()` происходит перемещение объекта в нужное место.
4. Далее вызывает функцию `add_log()`, которая добавляет информацию о выполненной команде в лог-файл.
5. Вызывает функцию `add_to_history()`, которая записывает команду в историю.

**Исключения:**

- `FileNotFoundError`:
  - Вывод: `File "..." doesn't exist.`
- `OSError`:
  - Вывод: При появлении исключения выводит пользователю текст исключения.
  - Также как в пунктах 4-5 добавляет информацию об исключении в лог-файл и историю.

---

## Функция `rm()`

Данная функция соответствует команде `mv()` в консоли. Функция удаляет указанный файл или директорию. Также функция поддерживает флаг `-r`, который применим только при удалении директорий и указывает функции, что следует рекурсивно удалить указанную директорию.

**Принцип работы:**

1. При помощи `os.path.join()` создаётся путь к удаляемому объекту.
2. Далее происходит проверка, не передан ли в качестве удаляемого файла аргумент `"/"` или `".."` или не передан ли путь к корневому каталогу:
   - Если передан один из этих аргументов, то вызывается исключение.
3. Далее при помощи `os.makedirs()` происходит создание (в случае, если её нет) директории `.trash`.
4. Далее функция создаёт уникальное имя для файла, чтобы поместить его в директорию `.trash`.
   **Формирование уникального имени:**
   1. При помощи `datetime.now().strftime()` записываем в переменную `time` дату и время удаления объекта в формате (год:месяц:день_часы:минуты:секунды).
   2. При помощи `basename()` записывает в переменную `base_name` имя удаляемого файла.
   3. При помощи `os.path.join()` создаёт путь к удаляемому файлу в директории `.trash` с именем `({base_name}_{time})`.
5. Далее при помощи `os.path.relpath()` создаёт путь от текущей директории к удаляемому файлу.
6. Проверяет на наличие пути из пункта 5 (проверяет, не находится ли удаляемый файл в текущей директории):
   1. Если такой путь есть, то создаём аналогичный путь, только уже внутри директории `.trash`.
   2. Далее, если такого каталога внутри `.trash` ещё нет, то при помощи `os.makedirs()` он создаётся, и после создания изменяем путь к файлу в директории `.trash` (был путь `.trash/file`, а стал `.trash/dirs/file`).
7. Далее идёт проверка флага `-r` и проверка на директорию:
   1. Если есть флаг `-r` и объект является директорией, то запрашиваем у пользователя подтверждение действия. Далее в зависимости от ответа производим либо удаление с помощью `shutil.move()`, либо отменяем команду и выводим сообщение: `Operation cancelled`.
   2. Если же отсутствует флаг `-r`, но объект является директорией, то вызывается исключение `IsADirectoryError`.
   3. Однако если объект не является директорией, то программа пытается при помощи `shutil.copy2()` и `os.remove()` скопировать файл в `.trash`. Однако если вызывается исключение, то программа делает вторую попытку переместить файл при помощи `shutil.move()`.
      *Это наверное "костыль", но мне пришлось сделать именно так, так как в некоторых случаях первый способ вызывал исключение.*
8. Далее вызывает функцию `add_log()`, которая добавляет информацию о выполненной команде в лог-файл.
9. Вызывает функцию `add_to_history()`, которая записывает команду в историю.

**Исключения:**

- `IsADirectoryError`:
  - Вывод: `"..." is a directory.`
- `FileNotFoundError`:
  - Вывод: `File "..." doesn't exist.`
- `PermissionError`:
  - Вывод: `Can't delete root directory.`
- `OSError`:
  - Вывод: При появлении исключения выводит пользователю текст исключения.
  - Также как в пунктах 8-9 добавляет информацию об исключении в лог-файл и историю.

---

## Функция `show_history()`

Данная функция выводит историю пользователю.

**Принцип работы:**

1. Проверка существования списка команд. Если он отсутствует, выводит пользователю сообщение: `No command in history`.
2. Вычисление стартового индекса:
   1. Если команд в списке больше, чем пользователь просит вывести, то стартовый индекс равен: количество команд в списке - число, переданное пользователем.
   2. Если команд в списке меньше, чем просит пользователь, то стартовый индекс равен 0.
3. Проходит по каждой команде в списке, начиная со стартового индекса:
   1. Считывает статус выполнения команды.
   2. Считывает время выполнения команды.
   3. Считывает список аргументов команды.
   4. Выводит команду пользователю в формате: `"{i} {status} [{time}] {info['command']} {str_args}"`.
4. Далее вызывает функцию `add_log()`, которая добавляет информацию о выполненной команде в лог-файл.
5. Вызывает функцию `add_to_history()`, которая записывает команду в историю.

**Исключения:**

- `OSError`:
  - Вывод: При появлении исключения выводит пользователю текст исключения.

---

## Функция `undo()`

Данная функция отменяет результат выполнения последней команды (команда должна иметь статус = `"success"`). Поддерживает отмену команд: `cp`, `rm`, `mv`.

**Принцип работы:**

1. Проверка существования списка команд. Если он отсутствует, выводит пользователю сообщение: `No command to cancel`.
2. Проходит по списку команд в обратном порядке (от новых к старым).
   1. Если команда является одной из этих: (`cp`, `rm`, `mv`), и статус команды равен `"success"`, то команда сохраняется как последняя команда, которую можно отменить.
3. Если команды, которые возможно отменить, отсутствуют, то пользователю выводится сообщение: `No commands to cansel`.
4. Далее алгоритм разнится в зависимости от отменяемой команды:

   - **cp**:
     1. Из дополнительной информации об операции берём путь к месту, куда был скопирован объект.
     2. Проверка на существование места и скопированного объекта.
     3. Далее если объект — файл, при помощи `os.remove()` он удаляется. Если же объект — директория, то при помощи `shutil.rmtree()` она удаляется.
   - **mv**:
     1. Из дополнительной информации об операции берём путь к месту, где изначально находился объект, и путь к месту, куда был перемещён объект.
     2. Проверка на существование мест и перемещённого объекта.
     3. Далее при помощи `shutil.move()` объект перемещается на изначальное место.
   - **rm**:
     1. Из дополнительной информации об операции берём путь к месту, куда был перемещён объект в директории `.trash`, а также берём путь к его местоположению до удаления.
     2. Проверка на существование мест и перемещённого в `.trash` объекта.
     3. Результаты проверки:
        - Если проверка пройдена, то при помощи `shutil.move()` перемещает объект на прежнее место.
        - Если проверка не пройдена, выводит пользователю сообщение об ошибке: `Couldn't cancel operation`.

5. Удаляет отменённую команду из списка при помощи `remove()`.
6. Далее вызывает функцию `save_history()`, которая перезаписывает историю, удаляя отменённую команду и добавляя команду `undo`.
7. Далее вызывает функцию `add_log()`, которая добавляет информацию о выполненной команде в лог-файл.
8. Вызывает функцию `add_to_history()`, которая записывает команду в историю.

**Исключения:**

- `OSError`:
  - Вывод: При появлении исключения выводит пользователю текст исключения.

---

## Функция `run()`

Данная функция запускает основной цикл выполнения программы. Также функция обрабатывает пользовательский ввод, парсит команды и в соответствии с результатами парсинга вызывает соответствующие функции.

**Принцип работы:**

1. Запускает цикл `while True`, который останавливается только после введения пользователем команды `exit`.
2. С помощью функции `input()` программа считывает введённые пользователем команды.
3. Далее эти команды парсятся (делятся на название и список аргументов и атрибутов).
4. Далее система вызывает соответствующую введённой пользователем команде функцию. В качестве аргументов для вызываемых функций программа берёт значения из списка аргументов, также анализируя наличие флагов.
5. Если аргументов не хватает, то программа выводит пользователю ошибку: `not enouth arguments`.

**Исключения:**

- `KeyboardInterrupt`:
  - Вывод: `Use 'exit' to quit.`
- `Exception`:
  - Вывод: `Unexpected error: "текст ошибки".`

---

Итак, здесь я постарался подробно описать работу каждой функции программы, а также затронул несколько нюансов и сложностей при разработке **System_Shell**.

**Спасибо за внимание к моей лабораторной работе!**
